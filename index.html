<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Checkers</title>
  <style>
    :root {
      --cell-size-px: 64px;
      --white0: rgb(220, 220, 220);
      --black0: rgb(50, 50, 50);
      --white1: rgb(180, 180, 180);
      --black1: rgb(100, 100, 100);
    }
    .board-table, .board-cell, .board-row {
      border: 0;
      padding: 0;
      margin: 0;
    }
    .board-cell {
      width: var(--cell-size-px);
      height: var(--cell-size-px);
      max-width: var(--cell-size-px);
      max-height: var(--cell-size-px);
      position: relative;
    }
    .cell-text {
      position: absolute;
      top: 50%;
      left: 0;
      transform: translateY(-50%);
      color: white;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      opacity: 0.05;
      font-family: monospace;
      font-size: 13px;
    }
    .cell-text:hover {
      opacity: 0.8;
    }
    .board-cell.black {
      background-color: var(--black0);
    }
    .board-cell.white {
      background-color: var(--white0);
    }

    .piece {
      position: absolute;
    }

    .piece.man {
      top: 50%;
      left: 50%;
      transform: translateY(-50%) translateX(-50%);
      width: calc(3/4 * var(--cell-size-px));
      height: calc(3/4 * var(--cell-size-px));
      border-radius: 100%;
    }

    .piece.king {
      top: 50%;
      left: 50%;
      transform: translateY(-50%) translateX(-50%) rotate(45deg);
      width: calc(1/2 * var(--cell-size-px));
      height: calc(1/2 * var(--cell-size-px));
    }

    .piece.white {
      background-color: var(--white0);
      border: 2px solid var(--black1);
    }
    .piece.black {
      background-color: var(--black0);
      border: 2px solid var(--white1);
    }
  </style>
</head>
<body>

<table id="board-table"></table>

<script>
'use strict'

const pieceElemMatrix = createBoardTable(document.querySelector('#board-table'))

const game = makeInitialGame()

renderBoard(game.board, pieceElemMatrix)

const testBoard = decodeBoard([
  '........',
  '.x......',
  '..@.....',
  '.x......',
  '....x...'
].join('\n'));

renderBoard(testBoard, pieceElemMatrix);

console.log(getCaptureDestinations(testBoard, { row: 2, col: 2 }));

/**
 * Creates the table representing the board in the DOM
 * Already creates both 'man' and 'king' pieces in all board cells,
 * so to render a particular board we just toggle the visibility and colors of existing elements
 * 
 * @param {HTMLTableElement} tableElem
 * 
 * @return {Array} Piece elements indexed by position
 */
function createBoardTable(tableElem) {
  tableElem.setAttribute('cellspacing', 0)
  const pieceElemMatrix = Array(8)

  for (let i = 0; i < 8; i++) {
    pieceElemMatrix[i] = Array(8)

    const rowElem = document.createElement('tr')
    rowElem.classList.add('board-row')

    for (let j = 0; j < 8; j++) {
      const cellElem = document.createElement('td');
      const cellColorClass = (i + j) % 2 == 0 ? 'white' : 'black';
      cellElem.classList.add('board-cell', cellColorClass)

      const manPieceElem = document.createElement('div')
      manPieceElem.classList.add('piece', 'man')
      manPieceElem.style.visibility = 'hidden'

      const kingPieceElem = document.createElement('div')
      kingPieceElem.classList.add('piece', 'king')
      kingPieceElem.style.visibility = 'hidden'

      pieceElemMatrix[i][j] = { 
        manElem: manPieceElem,
        kingElem: kingPieceElem
      }

      const text = document.createElement('span')
      text.classList.add('cell-text')
      text.innerHTML = `row: ${i}\ncol: ${j}`;

      cellElem.append(manPieceElem)
      cellElem.append(kingPieceElem)
      cellElem.append(text)

      rowElem.append(cellElem)
    }

    tableElem.append(rowElem)
  }

  return pieceElemMatrix
}

/**
 * @param {Array} arr
 * @param {HTMLTableElement} table
 */
function renderBoard(arr, pieceElemMatrix) {
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const { manElem, kingElem } = pieceElemMatrix[i][j]
      const piece = arr[i][j]

      if (!piece) {
        manElem.style.visibility = 'hidden'
        kingElem.style.visibility = 'hidden'
      } else {
        let pieceElem
        if (piece.king) {
          manElem.style.visibility = 'hidden'
          kingElem.style.visibility = 'visible'
          pieceElem = kingElem
        } else {
          manElem.style.visibility = 'visible'
          kingElem.style.visibility = 'hidden'
          pieceElem = manElem
        }
        
        if (piece.white) {
          pieceElem.classList.remove('black')
          pieceElem.classList.add('white')
        } else {
          pieceElem.classList.remove('white')
          pieceElem.classList.add('black')
        }
      }
    }
  }
}

/**
 * Board definition:
 * 8x8 matrix
 * null represents an empty cell
 * { white: boolean, king: boolean } represents a cell containing a piece
 */

function makeEmptyBoard() {
  const board = Array(8)
  for (let i = 0; i < 8; i++) {
    board[i] = Array(8)
  }
  return board
}

function makeInitialBoard() {
  const board = makeEmptyBoard()

  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 8; j++) {
      if ((i + j) % 2 != 0) {
        board[i][j] = { white: true, king: false }
      }
    }
  }

  for (let i = 5; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      if ((i + j) % 2 != 0) {
        board[i][j] = { white: false, king: false }
      }
    }
  }

  return board
}

/**
 * Creates the initial game state
 * 
 * @return {Object}
 */
function makeInitialGame() {
  return {
    whitesTurn: true,
    board: makeInitialBoard()
  }
}


// TODO doc
function getCaptureDestinations(board, piecePosition) {
  const src = piecePosition
  const srcPiece = board[src.row][src.col]

  if (!srcPiece) {
    return []
  }

  const result = []
  const reach = srcPiece.king ? 100 : 2  // arbitrary large number for unlimited reach

  // attack destination:
  // first empty position
  // - within reach
  // - in a diagonal
  // - after one and only one enemy piece

  // row and column step to iterate through all four diagonals
  for (let rstep of [-1, 1]) {
    for (let cstep of [-1, 1]) {

      // capture is true when the previous piece was capturable
      let capture = false
      const pos = { row: src.row+rstep, col: src.col+cstep };

      for (let dist = 1; dist <= reach; dist++) {

        if (pos.row < 0 || pos.row > 7 || pos.col < 0 || pos.col > 7) {
          break
        }

        const piece = board[pos.row][pos.col]

        if (piece != null) {
          if (capture) {
            // previous piece capturable, but no empty space to land on
            break
          } else if (piece.white == srcPiece.white) {
            // can't capture pieces of the same color
            break
          } else {
            // this piece is capturable, let's see in the next iteration whether we can actually capture it
            capture = true
          }
        } else if (capture) {
          // this is the first empty position after an enemy piece
          result.push(pos)
          break
        }

        pos.row += rstep
        pos.col += cstep
      }
    }
  }

  return result
}

/**
 * --- Debugging functions
 */

/**
 * Encodes the given board as a string
 * 
 * @param {Array}
 * 
 * @return {string}
 */
function encodeBoard(board) {
  let enc = '';
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const piece = board[i][j];
      if (piece) {
        if (piece.white) enc += piece.king ? '@' : 'o';
        else             enc += piece.king ? '#' : 'x';
      } else {
        enc += '.';
      }
    }
    if (i < 7) enc += '\n';
  }
  return enc
}

/**
 * Decodes the given string as a board
 * 
 * @param {string}
 * 
 * @return {Array}
 */
function decodeBoard(str) {
  const board = makeEmptyBoard()

  const rows = str.split('\n');
  const rowsLen = Math.min(8, rows.length);

  let i;
  for (i = 0; i < rowsLen; i++) {
    const cols = rows[i].split('');
    if (cols.length < 8) return null;

    for (let j = 0; j < 8; j++) {
      const ch = cols[j];
      switch (ch) {
        case 'x': board[i][j] = { white: false, king: false }; break;
        case '#': board[i][j] = { white: false, king: true }; break;
        case 'o': board[i][j] = { white: true,  king: false }; break;
        case '@': board[i][j] = { white: true,  king: true }; break;
        case '.': default: board[i][j] = null; break;
      }
    }
  }
  // explicitely fill the rest of the board, so it's null, not undefined
  for (; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      board[i][j] = null
    }
  }
  return board
}

</script>

</body>
</html>