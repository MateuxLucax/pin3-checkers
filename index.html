<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Checkers</title>
  <style>
    :root {
      --cell-size-px: 36px;
      --white0: rgb(220, 220, 220);
      --black0: rgb(50, 50, 50);
      --white1: rgb(180, 180, 180);
      --black1: rgb(100, 100, 100);
    }
    .board-table, .board-cell, .board-row {
      border: 0;
      padding: 0;
      margin: 0;
    }
    .board-cell {
      width: var(--cell-size-px);
      height: var(--cell-size-px);
      max-width: var(--cell-size-px);
      max-height: var(--cell-size-px);
      position: relative;
    }
    .cell-text {
      position: absolute;
      top: 50%;
      left: 0;
      width: 100%;
      height: 100%;
      transform: translateY(-50%);
      color: white;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      opacity: 0.05;
      font-family: monospace;
      font-size: 13px;
    }
    .cell-text:hover {
      cursor: default;
      opacity: 0.8;
    }
    .board-cell.black {
      background-color: var(--black0);
    }
    .board-cell.white {
      background-color: var(--white0);
    }

    .piece {
      position: absolute;
    }

    .piece.man {
      top: 50%;
      left: 50%;
      transform: translateY(-50%) translateX(-50%);
      width: calc(3/4 * var(--cell-size-px));
      height: calc(3/4 * var(--cell-size-px));
      border-radius: 100%;
    }

    .piece.king {
      top: 50%;
      left: 50%;
      transform: translateY(-50%) translateX(-50%) rotate(45deg);
      width: calc(1/2 * var(--cell-size-px));
      height: calc(1/2 * var(--cell-size-px));
    }

    .piece.white {
      background-color: var(--white0);
      border: 2px solid var(--black1);
    }
    .piece.black {
      background-color: var(--black0);
      border: 2px solid var(--white1);
    }
  </style>
</head>
<body>

<table id="board-table"></table>

<div id="container1"></div>
<div id="container2" style="margin-top: 10px"></div>

<script>
'use strict'

// some quick and dirty code just to test the functions

// TODO organize these tests, maybe
// TODO make the functions more robust (check if in bounds, move is diagonal etc. then throw when these conditions aren't met)

// test rendering
// const pieceElemMatrix = createBoardTable(document.querySelector('#board-table'), false)
// renderBoard(makeInitialBoard(), pieceElemMatrix)

// test getSingleCaptureDestinations
// const testBoard = decodeBoard([
//   '........',
//   '.x......',
//   '..@.....',
//   '.x......',
//   '....x...'
// ].join('\n'));
// renderBoard(testBoard, pieceElemMatrix);
// console.log(getSingleCaptureDestinations(testBoard, { row: 2, col: 2 }));

const testBoard = decodeBoard([
  '....o...',
  '........',
  '..@.....',
  '.x......',
  '....x...'
].join('\n'));

// test getRegularMoves
// renderBoard(testBoard, pieceElemMatrix);
// console.log({ row: 2, col: 2 }, getRegularMoves(testBoard, { row: 2, col: 2 }));
// console.log({ row: 0, col: 4 }, getRegularMoves(testBoard, { row: 0, col: 4 }));
// console.log({ row: 3, col: 1 }, getRegularMoves(testBoard, { row: 3, col: 1 }));
// console.log({ row: 4, col: 4 }, getRegularMoves(testBoard, { row: 4, col: 4 }));

//                     v source                            v capture dame    v become king
const moveSequence = [ {row: 4, col: 4}, {row: 3, col: 3}, {row: 1, col: 1}, {row: 0, col: 2} ]
const moveInfoStack = []
const tableContainer1 = document.querySelector('#container1')

const table = document.createElement('table')
table.style.display = 'inline'
renderBoard(testBoard, createBoardTable(table))
tableContainer1.append(table)

for (let moveIdx = 1; moveIdx < moveSequence.length; moveIdx++) {
  const from = moveSequence[moveIdx-1]
  const to   = moveSequence[moveIdx]

  const moveInfo = moveDo(testBoard, from, to)
  console.log('moveInfo', moveInfo)
  moveInfoStack.push(moveInfo)

  const table = document.createElement('table')
  table.style.display = 'inline'
  table.style.marginLeft = '10px'
  renderBoard(testBoard, createBoardTable(table))
  tableContainer1.append(table)
}

const tableContainer2 = document.querySelector('#container2')

for (let moveIdx = moveSequence.length-1; moveIdx >= 1; moveIdx--) {
  const from = moveSequence[moveIdx-1]
  const to   = moveSequence[moveIdx]
  const moveInfo = moveInfoStack.pop()
  moveUndo(testBoard, from, to, moveInfo)

  const table = document.createElement('table')
  table.style.display = 'inline'
  table.style.marginLeft = moveIdx == moveSequence.length-1 ? '' : '10px'
  renderBoard(testBoard, createBoardTable(table))
  tableContainer2.append(table)
}

/**
 * Takes an empty table and creates the rows/cells to represent a board
 * Already creates a piece element in all board cells
 * so to render a particular board we just toggle visibility and classes.
 * 
 * @param {HTMLTableElement} tableElem
 * @param {boolean} overlayCoords Whether to overlay "row: n", "col: m" onto the cells
 * 
 * @return {Array} Piece elements indexed by position
 */
function createBoardTable(tableElem, overlayCoords=true) {
  tableElem.setAttribute('cellspacing', 0)
  const pieceElemMatrix = Array(8)

  for (let i = 0; i < 8; i++) {
    pieceElemMatrix[i] = Array(8)

    const rowElem = document.createElement('tr')
    rowElem.classList.add('board-row')

    for (let j = 0; j < 8; j++) {
      const cellElem = document.createElement('td');
      const cellColorClass = (i + j) % 2 == 0 ? 'white' : 'black';
      cellElem.classList.add('board-cell', cellColorClass)

      const pieceElem = document.createElement('div')
      pieceElem.classList.add('piece')
      pieceElem.style.visibility = 'hidden'

      pieceElemMatrix[i][j] = pieceElem

      cellElem.append(pieceElem)

      if (overlayCoords) {
        const text = document.createElement('span')
        text.classList.add('cell-text')
        text.innerHTML = `r${i}<br>c${j}`;
        cellElem.append(text)
      }

      rowElem.append(cellElem)
    }

    tableElem.append(rowElem)
  }

  return pieceElemMatrix
}

/**
 * @param {Array} arr
 * @param {HTMLTableElement} table
 */
function renderBoard(arr, pieceElemMatrix) {
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const elem = pieceElemMatrix[i][j]
      const piece = arr[i][j]

      if (!piece) {
        elem.style.visibility = 'hidden'
      } else {
        elem.style.visibility = 'visible'
        if (piece.king) {
          elem.classList.remove('man')
          elem.classList.add('king')
        } else {
          elem.classList.remove('king')
          elem.classList.add('man')
        }
        
        if (piece.white) {
          elem.classList.remove('black')
          elem.classList.add('white')
        } else {
          elem.classList.remove('white')
          elem.classList.add('black')
        }
      }
    }
  }
}

/**
 * --- Board definition:
 * 8x8 matrix
 * null represents an empty cell
 * { white: boolean, king: boolean } represents a cell containing a piece
 */

function makeEmptyBoard() {
  const board = Array(8)
  for (let i = 0; i < 8; i++) {
    board[i] = Array(8)
  }
  return board
}

function makeInitialBoard() {
  const board = makeEmptyBoard()

  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 8; j++) {
      if ((i + j) % 2 != 0) {
        board[i][j] = { white: true, king: false }
      }
    }
  }

  for (let i = 5; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      if ((i + j) % 2 != 0) {
        board[i][j] = { white: false, king: false }
      }
    }
  }

  return board
}

// we'll do/undo moves
// because instead of always generating brand new states when examining possibilites
// we'll do backtracking: do moves on the way down the tree (just before recursive call),
// undo on the way up (just after recursive call)

// TODO when doing/undoing moves
// also undo captures
// also undo crowning
// need to return both as extra information

function moveDo(board, from, to) {
  // assumes positions are in bounds, and that the move is diagonal (from.row-to.row = from.col-to.col)
  const diff = Math.abs(from.row - to.row);

  let crowned = null
  let captured = null

  if (diff > 1) {
    // go one step back from 'to' to 'from'
    const rstep = to.row > from.row ? -1 : 1
    const cstep = to.col > from.col ? -1 : 1
    // store and make the capture
    captured = { row: to.row+rstep, col: to.col+cstep }
    captured.piece = board[captured.row][captured.col]
    board[captured.row][captured.col] = null
  }

  const piece = board[from.row][from.col]
  board[to.row][to.col] = piece
  board[from.row][from.col] = null

  const crown = (piece.white && to.row == 7) || (!piece.white && to.row == 0)
  if (!piece.king && crown) {
    piece.king = true
    crowned = { row: to.row, col: to.col }
  }

  // returns { crowned: null|{row, col}, captured: null|{row, col, piece} }, where piece = {white, king}
  return { crowned, captured }
}

function moveUndo(board, from, to, { crowned, captured }) {
  const piece = board[to.row][to.col]
  if (crowned != null) {
    piece.king = false
  }
  if (captured != null) {
    board[captured.row][captured.col] = captured.piece
  }
  board[to.row][to.col] = null
  board[from.row][from.col] = piece
}

/**
 * --- Movement generation
 */

// TODO doc
function getRegularMoveDestinations(board, piecePosition) {
  const src = piecePosition
  const srcPiece = board[src.row][src.col]

  if (!srcPiece) return []

  const csteps = [-1, 1]

  let rsteps
  if (srcPiece.king) {
    rsteps = [-1, 1]
  } else if (srcPiece.white) {
    rsteps = [1]
  } else {
    rsteps = [-1]
  }

  const result = []
  const reach = srcPiece.king ? 100 : 1

  for (const rstep of rsteps) {
    for (const cstep of csteps) {
      const pos = { row: src.row+rstep, col: src.col+cstep }
      for (let dist = 1; dist <= reach; dist++) {
        if (pos.row < 0 || pos.row > 7 || pos.col < 0 || pos.col > 7) {
          break
        }

        const piece = board[pos.row][pos.col]
        if (piece != null) {
          break
        }

        result.push({ row: pos.row, col: pos.col })

        pos.row += rstep
        pos.col += cstep
      }
    }
  }

  return result
}

// TODO doc
function getSingleCaptureDestinations(board, piecePosition) {
  const src = piecePosition
  const srcPiece = board[src.row][src.col]

  if (!srcPiece) {
    return []
  }

  const result = []
  const reach = srcPiece.king ? 100 : 2  // arbitrary large number for unlimited reach

  // attack destination:
  // first empty position
  // - within reach
  // - in a diagonal
  // - after one and only one enemy piece

  // row and column step to iterate through all four diagonals
  for (const rstep of [-1, 1]) {
    for (const cstep of [-1, 1]) {

      // capture is true when the previous piece was capturable
      let capture = false
      const pos = { row: src.row+rstep, col: src.col+cstep };

      for (let dist = 1; dist <= reach; dist++) {

        if (pos.row < 0 || pos.row > 7 || pos.col < 0 || pos.col > 7) {
          break
        }

        const piece = board[pos.row][pos.col]

        if (piece != null) {
          if (capture) {
            // previous piece capturable, but no empty space to land on
            break
          } else if (piece.white == srcPiece.white) {
            // can't capture pieces of the same color
            break
          } else {
            // this piece is capturable, let's see in the next iteration whether we can actually capture it
            capture = true
          }
        } else if (capture) {
          // this is the first empty position after an enemy piece
          result.push({ row: pos.row, col: pos.col })
          break
        }

        pos.row += rstep
        pos.col += cstep
      }
    }
  }

  return result
}

/**
 * --- Debugging functions
 */

/**
 * Encodes the given board as a string
 * 
 * @param {Array}
 * 
 * @return {string}
 */
function encodeBoard(board) {
  let enc = '';
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      const piece = board[i][j];
      if (piece) {
        if (piece.white) enc += piece.king ? '@' : 'o';
        else             enc += piece.king ? '#' : 'x';
      } else {
        enc += '.';
      }
    }
    if (i < 7) enc += '\n';
  }
  return enc
}

/**
 * Decodes the given string as a board
 * 
 * @param {string}
 * 
 * @return {Array}
 */
function decodeBoard(str) {
  const board = makeEmptyBoard()

  const rows = str.split('\n');
  const rowsLen = Math.min(8, rows.length);

  let i;
  for (i = 0; i < rowsLen; i++) {
    const cols = rows[i].split('');
    if (cols.length < 8) return null;

    for (let j = 0; j < 8; j++) {
      const ch = cols[j];
      switch (ch) {
        case 'x': board[i][j] = { white: false, king: false }; break;
        case '#': board[i][j] = { white: false, king: true }; break;
        case 'o': board[i][j] = { white: true,  king: false }; break;
        case '@': board[i][j] = { white: true,  king: true }; break;
        case '.': default: board[i][j] = null; break;
      }
    }
  }
  // explicitely fill the rest of the board, so it's null, not undefined
  for (; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      board[i][j] = null
    }
  }
  return board
}

</script>

</body>
</html>