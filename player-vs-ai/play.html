<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Checkers | Player vs. AI</title>
  <link rel="shortcut icon" type="image/png" href="/assets/image/favicon.png" />
  <link rel="apple-touch-icon" href="/assets/image/favicon.png" />
  <link rel="stylesheet" href="/assets/style/main.css" />
  <link rel="stylesheet" href="/assets/style/reset.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap" />
  <link rel="stylesheet" media="print" onload="this.onload=null;this.removeAttribute('media');" href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap" />
  <noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap" />
  </noscript>
</head>

<body>
  <main>
    <div class="board-container">
    </div>

    <div class="loader-container" style="display: none;">
      <div class="loader"></div>
    </div>
  </main>

  <script type="module">

    // nice shortcut borrowed from Java
    Map.prototype.computeIfAbsent = function(key, fn) {
      let result = this.get(key)
      if (result === undefined) {
        result = fn(key)
        this.set(key, result)
      }
      return result
    }

    import * as bo from '/assets/js/board.js'
    import BoardView from '/assets/js/BoardView.js'
    import {CheckersState, Status} from '/assets/js/game-state.js'
    import * as mov from '/assets/js/move-generation.js'
    import * as mm from '/assets/js/minimax.js'

    // const minimaxWorker = new Worker('/assets/js/minimax-worker.js', { type: 'module' })

    const loaderContainer = document.querySelector('.loader-container')

    // TODO make the loader smaller and put it outside the board
    // currently it's hard to see which action the AI took
    const toggleLoad = () => {
      if (window.getComputedStyle(loaderContainer).display == 'flex') {
        loaderContainer.style.display = 'none'
      } else {
        loaderContainer.style.display = 'flex'
      }
    }

    // First player = white = human

    // for testing how to show all possible movement options of a piece (particularly complex example, but we should be able to handle it)
    // const initialBoard = bo.decodeBoard([
    //   '.....@..',
    //   '........',
    //   '...x....',
    //   '........',
    //   '.....x..',
    //   '..x.....',
    //   '.....x..',
    //   '........',
    // ].join('\n'));
    const initialBoard = null

    const url = new URL(location)

    const captureOptions = mov.captureOptionsFromURL(url)
    const state = new CheckersState(captureOptions, initialBoard)

    function checkStatus() {
      if (state.status == Status.playing) return

      let msg = ''
      switch (state.status) {
        case Status.whiteWon: msg = 'White won!'; break
        case Status.blackWon: msg = 'Black won!'; break
        case Status.draw: msg = 'Draw...'; break
      }
      alert(msg)
      location.reload()
    }

    const heuristic = url.searchParams.get('heuristic') ?? 'countPieces'
    const depth = url.searchParams.get('depth') ?? 8
    const minimax = new mm.Minimax(false, mm[heuristic], depth)

    // this works, but still feels like a bad way to implement this, the code reads weird etc

    const ViewState = Object.freeze({
      waitingSource:   0,
      waitingMovement: 1,
      away:            2, // animating human movement + waiting AI + animating AI movement
    })

    const boardView = new BoardView(state.board, document.querySelector('.board-container'))

    const currentGameState = {
      viewState: ViewState.waitingSource,
      destinationToMovementList: new Map(),

      waitSourceSelection() {
        currentGameState.viewState = ViewState.waitingSource
        currentGameState.humanMovementChoices = state.actions
        currentGameState.destinationToMovementList.clear()
        boardView.resetMarks(
          new Set(state.actions.map(mov => mov.from))
        )
      },

      handleClick(row, col, marked) {
        currentGameState.clickHandlers[currentGameState.viewState](row, col, marked)
      },

      clickHandlers: {
        [ViewState.away]: () => { return },

        [ViewState.waitingSource]: (row, col, marked) => {
          if (!marked) return

          const selectedPieceMovementOptions = state.actions.filter(mov =>
            mov.from.row == row && mov.from.col == col
          )

          boardView.clearMarks()
          for (const movement of selectedPieceMovementOptions) {
            const destination = movement.sequence[ movement.sequence.length-1 ]
            boardView.addMark(destination)
            const serialized = bo.serializePosition(destination)
            currentGameState.destinationToMovementList.computeIfAbsent(serialized, () => []).push(movement)
          }

          currentGameState.viewState = ViewState.waitingMovement
        },

        [ViewState.waitingMovement]: (row, col, marked) => {
          if (!marked) {
            // Return to waitingSource state
            currentGameState.waitSourceSelection()
          } else {
            const movements = currentGameState.destinationToMovementList.get(bo.serializePosition({ row, col }))
            const action = movements[0]
            state.actionDo(action) // obtain undoInfo
 
            currentGameState.viewState = ViewState.away
            boardView.clearMarks()
            boardView.animateAction(action).then(() => {

              checkStatus()

              const { action: aiAction } = minimax.val(state)
              state.actionDo(aiAction) // obtain undoInfo

              boardView.animateAction(aiAction).then(() => {
                checkStatus()
                currentGameState.waitSourceSelection()
              })
            })
          }
        }
      },

    }

    boardView.onClick(currentGameState.handleClick)

    currentGameState.waitSourceSelection()
  </script>

</body>

</html>