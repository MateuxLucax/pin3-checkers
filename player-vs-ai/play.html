<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Checkers | Player vs. AI</title>
  <link rel="shortcut icon" type="image/png" href="/assets/image/favicon.png" />
  <link rel="apple-touch-icon" href="/assets/image/favicon.png" />
  <link rel="stylesheet" href="/assets/style/main.css" />
  <link rel="stylesheet" href="/assets/style/reset.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap" />
  <link rel="stylesheet" media="print" onload="this.onload=null;this.removeAttribute('media');" href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap" />
  <noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&display=swap" />
  </noscript>
</head>

<body>
  <main>
    <div id="board-container">
    </div>

    <div class="loader-container" style="display: none;">
      <div class="loader"></div>
    </div>
  </main>

  <script type="module">
    // TODO redo loader
    // TODO redo worker

    // TODO detect situations where there is position overlap in capture sequences and show one at a time instead of all at once
    // test with:
    // const initialBoard = bo.decodeBoard([
    //   '.....@..',
    //   '........',
    //   '...x....',
    //   '........',
    //   '.....x..',
    //   '..x.....',
    //   '.....x..',
    //   '........',
    // ].join('\n'));

    import { arePositionsEqual } from '/assets/js/board.js'
    import BoardView from '/assets/js/BoardView.js'
    import * as mm from '/assets/js/minimax.js'
    import { CheckersState, Status } from '/assets/js/game-state.js'
    import { captureOptionsFromURL } from '/assets/js/move-generation.js'

    const url = new URL(location)

    const heuristic = url.searchParams.get('heuristic') ?? 'countPieces'
    const depth = url.searchParams.get('depth') ?? 8
    const minimax = new mm.Minimax(false, mm[heuristic], depth)

    const captureOptions = captureOptionsFromURL(new URL(location))
    const checkers = new CheckersState(captureOptions)

    const viewContainer = document.getElementById('board-container')
    const view = new BoardView(checkers.board, viewContainer)

    let ignoreClicks = false
    let selectedSource = null

    function checkStatus() {
      if (checkers.status == Status.playing) return
      let msg = ''
      switch (checkers.status) {
        case Status.whiteWon: msg = 'White won!'; break
        case Status.blackWon: msg = 'Black won!'; break
        case Status.draw: msg = 'Draw...'; break
      }
      alert(msg)
      location.reload()
    }

    function waitForPieceSelection() {
      selectedSource = null
      view.resetMarks(checkers.actions.map(a => a.from))
    }

    view.onClick((row, col, marked) => {
      if (ignoreClicks) return

      if (!selectedSource) {
        if (!marked) return

        selectedSource = { row, col }
        view.resetMarks(
          checkers.actions
          .filter(a => arePositionsEqual(a.from, selectedSource))
          .map(a => a.sequence[a.sequence.length-1])
        )
      }
      else {
        if (!marked) {
          waitForPieceSelection()
          return
        }

        const selectedDestination = { row, col }
        const possibleActions = checkers.actions.filter(a =>
          arePositionsEqual(selectedSource, a.from) && arePositionsEqual(selectedDestination, a.sequence[a.sequence.length-1])
        )
        const actionTaken = possibleActions[0]

        checkers.actionDo(actionTaken)

        ignoreClicks = true
        view.clearMarks()
        view.animateAction(actionTaken).then(() => {
          checkStatus()

          const { action: aiAction } = minimax.val(checkers)
          checkers.actionDo(aiAction)

          view.animateAction(aiAction).then(() => {
            checkStatus()
            ignoreClicks = false
            waitForPieceSelection()
          })
        })
      }
    })

    waitForPieceSelection()
  </script>
</body>

</html>